
/*
 * ============================================================================
 * RFID Card Authentication System
 * ============================================================================
 * 
 * PROJECT: Texas Tech University (ECE-3363-001) Final Project
 * 
 * AUTHORS:
 *   Zaied Al Bayati
 *   Corbin Burgett
 *   Thomas Mccully
 *   
 *   March 2025
 *   Built with Cursor IDE
 *   Compiled using Energia IDE
 *
 *
 * DESCRIPTION:
 * This project implements an RFID card authentication system using the MFRC522
 * RFID reader module. The system provides a simple way to authenticate RFID cards
 * by checking if they contain a pre-configured password stored in non-volatile memory.
 * 
 * KEY FEATURES:
 *   - Reads RFID card UIDs and displays card memory contents
 *   - Stores authentication password in FRAM (non-volatile memory, MSP430FR6989 specific)
 *   - Automatically checks if detected cards contain the stored password
 *   - Visual feedback with LED indicators (green for authorized, red for unauthorized)
 *   - Easy password programming: press button during LED flash to write password to card
 * 
 * HOW IT WORKS:
 * 1. When you scan an RFID card, the system searches the card's memory for the stored password
 * 2. If the password is found: Green LED blinks for 3 seconds (authorized card)
 * 3. If the password is not found: Red LED blinks for 3 seconds (unauthorized card)
 * 4. During the 3-second LED blink period, you can press the button (Pin 45) to write
 *    the stored password to the card (useful for programming new cards)
 * 5. After successful write, both LEDs flash 5 times to confirm
 * 
 * SERIAL COMMANDS:
 * The system accepts commands via the serial monitor (9600 baud):
 *   - "password set X" - Sets the authentication password to X (up to 32 characters)
 *   - "rfid write X" - Writes data X directly to an RFID card
 * 
 * NOTE: The actual limits are PASSWORD_MAX_LEN (32 characters) and available RAM.
 * Make sure your Serial Monitor is set to send "Newline" or "Both NL & CR" as the
 * line ending so commands are properly terminated.
 * 
 * SETTING LONGER PASSWORDS:
 * If you need to set a password longer than what fits in one line, you can use a
 * multi-line approach. First type "password set XX" (where XX is the first 2
 * characters), then press Enter. Then continue typing the rest of your password
 * and press Enter again. The system will concatenate the parts together.
 * 
 * Example: To set password "Zaied"
 *   1. Type: "password set Za" and press Enter
 *   2. Type: "ied" and press Enter
 *   3. The system will store the complete password as "Zaied"
 * 
 * HARDWARE:
 *   - Microcontroller: MSP430FR6989 LaunchPad
 *   - RFID Reader: MFRC522 Module
 *   - Communication: SPI interface
 *   - Storage: FRAM (built-in to MSP430FR6989)
 * 
 * REFERENCES:
 * 
 * MFRC522 Library:
 * This code is built upon the open-source MFRC522 library for Energia:
 *   https://github.com/londonhackspace/mfrc522-energia.git
 * 
 * Serial Event Example (from Energia Examples):
 * The serial command handling uses a pattern based on the Serial Event example
 * found on Energia's examples page.
 * 
 * Serial Event example:
 *   Created 24 April 2013 by Sean Alvarado
 *   This example code is in the public domain.
 * 
 * Additional Serial examples:
 *   Created 29 Nov 2010 by Tom Igoe
 *   This example code is in the public domain.
 * 
 * ============================================================================
 * PINOUT TABLE
 * ============================================================================
 * 
 * Component        |  Energia Pin  |  MFRC522 Pin  |  Function          |  Notes
 * -----------------|---------------|---------------|--------------------|------------------
 * MFRC522 SDA (SS) |  Pin 8        |  SDA          |  Chip Select       |  SPI slave select
 * MFRC522 RST      |  Pin 10       |  RST          |  Reset             |  Active high reset
 * MFRC522 MOSI     |  MOSI         |  MOSI         |  SPI Data Out       |  Auto-configured by SPI library
 * MFRC522 MISO     |  MISO         |  MISO         |  SPI Data In        |  Auto-configured by SPI library
 * MFRC522 SCK      |  SCK          |  SCK          |  SPI Clock          |  Auto-configured by SPI library
 * Button           |  Pin 45       |  N/A          |  Button Input       |  Pull-up enabled, triggers write
 * RED LED          |  RED_LED      |  N/A          |  Status LED         |  Built-in LED (unauthorized)
 * GREEN LED        |  GREEN_LED    |  N/A          |  Status LED         |  Built-in LED (authorized)
 * Power            |  3.3V         |  3.3V         |  Power Supply       |  IMPORTANT: Use 3.3V only!
 * Ground           |  GND          |  GND          |  Common Ground      |  Connect all grounds together
 * 
 * NOTE: Pin numbers refer to Energia/Arduino pin numbering convention.
 *       SPI pins (MOSI, MISO, SCK) are automatically handled by SPI library.
 *       The MFRC522 module MUST be powered with 3.3V, not 5V!
 * 
 * ============================================================================
 * WIRING CONVERSION TABLE
 * ============================================================================
 * 
 * MFRC522 Module Pin  |  Connect To MSP430FR6989 LaunchPad  |  Code Variable Name
 * --------------------|-------------------------------------|--------------------
 * SDA (SS)            |  Digital Pin 8                      |  chipSelectPin
 * SCK                 |  SPI Clock (hardware SPI)           |  SCK (automatic)
 * MOSI                |  SPI Data Out (hardware SPI)        |  MOSI (automatic)
 * MISO                |  SPI Data In (hardware SPI)         |  MISO (automatic)
 * RST                 |  Digital Pin 10                     |  NRSTPD
 * IRQ                 |  Not connected (optional)            |  N/A
 * GND                 |  Ground (GND)                       |  GND
 * 3.3V                |  3.3V Power Pin                     |  3.3V
 * 
 * ADDITIONAL CONNECTIONS:
 *   - Button: Connect between Pin 45 and GND (internal pull-up enabled)
 *   - LEDs: Built-in to LaunchPad board (no external wiring needed)
 * 
 * WIRING STEPS:
 *   1. MFRC522 3.3V ------> LaunchPad 3.3V
 *   2. MFRC522 GND ------> LaunchPad GND
 *   3. MFRC522 SDA ------> LaunchPad Pin 8
 *   4. MFRC522 RST ------> LaunchPad Pin 10
 *   5. MFRC522 MOSI ------> LaunchPad MOSI (check board for exact pin)
 *   6. MFRC522 MISO ------> LaunchPad MISO (check board for exact pin)
 *   7. MFRC522 SCK ------> LaunchPad SCK (check board for exact pin)
 *   8. Button ------> Pin 45 and GND (optional, for password writing)
 * 
 * NOTE: The MFRC522 module requires 3.3V power. Do NOT use 5V as it may damage
 *       the module. The MSP430FR6989 operates at 3.3V, making it compatible.
 * 
 * ============================================================================
 * FUNCTIONALITY
 * ============================================================================
 * 
 * 1. INITIALIZATION:
 *    - Initializes SPI communication
 *    - Configures MFRC522 RFID reader
 *    - Loads stored password from FRAM
 *    - Sets up button and LED pins
 * 
 * 2. CARD DETECTION:
 *    - Continuously scans for RFID cards
 *    - Displays card UID when detected
 *    - Reads and displays card memory contents
 * 
 * 3. AUTHENTICATION:
 *    - Searches card memory for stored password
 *    - Tries multiple authentication keys (default, MAD, NDEF)
 *    - GREEN LED blinks for 3 seconds if password found (authorized)
 *    - RED LED blinks for 3 seconds if password not found (unauthorized)
 *    - LED blinking is non-blocking and continues during all operations
 * 
 * 4. PASSWORD WRITING:
 *    - When ANY card is detected and LED is blinking (red or green), user has
 *      3 seconds to press button (Pin 45)
 *    - Button press automatically writes stored password to the card
 *    - Both LEDs flash 5 times quickly to confirm successful write
 *    - Provides serial feedback on operation status
 *    - Works for both authorized and unauthorized cards, making it easy to
 *      program multiple cards quickly
 * 
 * 5. SERIAL COMMANDS:
 *    - "password set <text>" - Store password (1-16 characters)
 *    - "rfid write <text>" - Write data directly to card
 * 
 * ============================================================================
 * AUTHENTICATION KEYS
 * ============================================================================
 * 
 * The system attempts authentication with three common keys:
 *   - Default Key: 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
 *   - MAD Key:    0xA0 0xA1 0xA2 0xA3 0xA4 0xA5
 *   - NDEF Key:   0xD3 0xF7 0xD3 0xF7 0xD3 0xF7
 * 
 * ============================================================================
 */

#include <SPI.h>


#define uchar unsigned char
#define uint unsigned int

// Data array maximum length
#define MAX_LEN 32

// Pin definitions
const int chipSelectPin = 8;
const int NRSTPD = 10;

const int BUTTON_PIN = 45;     // Button pin

// Password storage in FRAM (MSP430FR6989 uses FRAM instead of EEPROM)
// Using INFO segment of FRAM for non-volatile storage
#define FRAM_INFO_START 0x1800  // INFO segment start address
#define PASSWORD_ADDR 0
#define PASSWORD_MAX_LEN 32

// FRAM access macros for MSP430FR6989
#define FRAM_PASSWORD_BASE (FRAM_INFO_START + PASSWORD_ADDR)

// ============================================================================
// GLOBAL VARIABLES
// ============================================================================

// RFID card identification numbers (UIDs)
uchar serNum[5];        // Standard 4-byte UID + checksum
uchar serNum7[8];       // Extended 7-byte UID

// Password storage and state
char storedPassword[PASSWORD_MAX_LEN + 1] = "";  // Password stored in RAM
bool passwordSet = false;  // Flag indicating if a password has been set

// Card authentication state
bool authorizedCardDetected = false;  // True if last card had the password
unsigned long authorizedTime = 0;     // Timestamp when authorized card was detected

// Card detection tracking
bool cardDetected = false;            // True when any card is currently detected
unsigned long cardDetectedTime = 0;   // Timestamp when card was first detected

// LED blinking state (non-blocking implementation)
bool ledFlashing = false;             // True when LED should be blinking
unsigned long ledFlashStartTime = 0;  // When LED blinking started
int ledFlashPin = -1;                 // Which LED is flashing (-1 = none, GREEN_LED or RED_LED)
unsigned long lastLedToggle = 0;      // Last time LED state was toggled
bool ledState = false;                // Current LED state (HIGH/LOW)
const unsigned long AUTHORIZED_WINDOW = 3000;  // LED blink duration (3 seconds)
const unsigned long LED_BLINK_INTERVAL = 200;   // Time between LED toggles (ms)

// Serial command input handling
String inputString = "";        // Accumulates characters from serial input
boolean stringComplete = false; // True when a complete line (ending in \n) is received

// Default authentication keys for MIFARE cards
// The system tries these keys in order to access card memory
uchar defaultKeyA[16] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };  // Factory default key
uchar madKeyA[16] = { 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5 };    // MAD (Manufacturer Application Data) key
uchar NDEFKeyA[16] = { 0xD3, 0xF7, 0xD3, 0xF7, 0xD3, 0xF7 };   // NDEF (NFC Data Exchange Format) key

// MF522 command bits
#define PCD_IDLE              0x00
#define PCD_AUTHENT           0x0E
#define PCD_RECEIVE           0x08
#define PCD_TRANSMIT          0x04
#define PCD_TRANSCEIVE        0x0C
#define PCD_RESETPHASE        0x0F
#define PCD_CALCCRC           0x03

// Mifare_One card command bits
#define PICC_REQIDL           0x26
#define PICC_REQALL           0x52
#define PICC_ANTICOLL         0x93
#define PICC_SElECTTAG        0x93
#define PICC_ANTICOLL2        0x95
#define PICC_ANTICOLL3        0x97
#define PICC_AUTHENT1A        0x60
#define PICC_AUTHENT1B        0x61
#define PICC_READ             0x30
#define PICC_WRITE            0xA0
#define PICC_DECREMENT        0xC0
#define PICC_INCREMENT        0xC1
#define PICC_RESTORE          0xC2
#define PICC_TRANSFER         0xB0
#define PICC_HALT             0x50

// Error codes
#define MI_OK                 0
#define MI_NOTAGERR           1
#define MI_ERR                2

// MFRC522 registers
#define Reserved00            0x00
#define CommandReg            0x01
#define CommIEnReg            0x02
#define DivlEnReg             0x03
#define CommIrqReg            0x04
#define DivIrqReg             0x05
#define ErrorReg              0x06
#define Status1Reg            0x07
#define Status2Reg            0x08
#define FIFODataReg           0x09
#define FIFOLevelReg          0x0A
#define WaterLevelReg         0x0B
#define ControlReg            0x0C
#define BitFramingReg         0x0D
#define CollReg               0x0E
#define Reserved01            0x0F
#define Reserved10            0x10
#define ModeReg               0x11
#define TxModeReg             0x12
#define RxModeReg             0x13
#define TxControlReg          0x14
#define TxAutoReg             0x15
#define TxSelReg              0x16
#define RxSelReg              0x17
#define RxThresholdReg        0x18
#define DemodReg              0x19
#define Reserved11            0x1A
#define Reserved12            0x1B
#define MifareReg             0x1C
#define Reserved13            0x1D
#define Reserved14            0x1E
#define SerialSpeedReg        0x1F
#define Reserved20            0x20
#define CRCResultRegM         0x21
#define CRCResultRegL         0x22
#define Reserved21            0x23
#define ModWidthReg           0x24
#define Reserved22            0x25
#define RFCfgReg              0x26
#define GsNReg                0x27
#define CWGsPReg              0x28
#define ModGsPReg             0x29
#define TModeReg              0x2A
#define TPrescalerReg         0x2B
#define TReloadRegH           0x2C
#define TReloadRegL           0x2D
#define TCounterValueRegH     0x2E
#define TCounterValueRegL     0x2F
#define Reserved30            0x30
#define TestSel1Reg           0x31
#define TestSel2Reg           0x32
#define TestPinEnReg          0x33
#define TestPinValueReg       0x34
#define TestBusReg            0x35
#define AutoTestReg           0x36
#define VersionReg            0x37
#define AnalogTestReg         0x38
#define TestDAC1Reg           0x39
#define TestDAC2Reg           0x3A
#define TestADCReg            0x3B
#define Reserved31            0x3C
#define Reserved32            0x3D
#define Reserved33            0x3E
#define Reserved34            0x3F

// ============================================================================
// SETUP FUNCTION - Runs once at startup
// ============================================================================
void setup() {
  // Initialize serial communication for debugging and commands
  Serial.begin(9600);
  
  // Reserve memory for serial input string to prevent fragmentation
  inputString.reserve(200);
  inputString = "";
  stringComplete = false;
  
  // Initialize SPI bus for RFID reader communication
  SPI.begin();
  
  // Configure RFID reader control pins
  pinMode(chipSelectPin, OUTPUT);   // SPI chip select (slave select)
  digitalWrite(chipSelectPin, LOW);  // Start with chip selected
  pinMode(NRSTPD, OUTPUT);           // Reset pin for MFRC522
  digitalWrite(NRSTPD, HIGH);        // Release reset (active high)
  
  // Configure LED pins
  pinMode(GREEN_LED, OUTPUT);
  pinMode(RED_LED, OUTPUT);
  digitalWrite(GREEN_LED, LOW);      // Ensure LEDs start OFF
  digitalWrite(RED_LED, LOW);
  
  // Configure button pin with internal pull-up resistor
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  
  // Initialize LED state tracking variables
  ledFlashing = false;
  ledFlashPin = -1;
  ledState = false;
  lastLedToggle = 0;
  
  // Initialize the MFRC522 RFID reader module
  MFRC522_Init();
  
  // Display RFID reader version for verification
  uchar version = Read_MFRC522(VersionReg);
  Serial.print("MFRC522 Version: 0x");
  Serial.println(version, HEX);
  
  // Load previously saved password from non-volatile FRAM memory
  loadPassword();
  
  // Display password status
  if (passwordSet) {
    Serial.print("Loaded password from FRAM: ");
    Serial.println(storedPassword);
  } else {
    Serial.println("No password set. Use 'password set X' to set one.");
  }
  
  // Display system ready message and available commands
  Serial.println("System ready. Commands:");
  Serial.println("  password set X - Set password to X");
  Serial.println("  rfid write X - Write X to RFID card");
  Serial.println("Scan a card to check it...");
  
  // Brief delay to ensure all initialization is complete
  delay(100);
  
  // Final safety check - ensure LEDs are definitely off
  digitalWrite(GREEN_LED, LOW);
  digitalWrite(RED_LED, LOW);
}

// ============================================================================
// MAIN LOOP - Runs continuously
// ============================================================================
void loop() {
  // ========================================================================
  // SERIAL COMMAND PROCESSING
  // ========================================================================
  // Process serial command when a complete line is received (ending in newline)
  // Note: Serial Monitor should be set to send "Newline" or "Both NL & CR"
  if (stringComplete) {
    checkSerialCommands(inputString);
    inputString = "";
    stringComplete = false;
  }
  
  // ========================================================================
  // LED BLINKING HANDLING (Non-blocking)
  // ========================================================================
  // Blink LED during the 3-second authorization window
  if (ledFlashing && (millis() - ledFlashStartTime < AUTHORIZED_WINDOW)) {
    // Toggle LED state at the specified blink interval
    if (millis() - lastLedToggle >= LED_BLINK_INTERVAL) {
      ledState = !ledState;
      digitalWrite(ledFlashPin, ledState ? HIGH : LOW);
      lastLedToggle = millis();
    }
    
    // Check if button is pressed during LED flash period (3-second window)
    // This allows writing password to card while LED is blinking
    if (digitalRead(BUTTON_PIN) == LOW) {
      delay(5);  // Minimal debounce time
      if (digitalRead(BUTTON_PIN) == LOW) {
        Serial.println("Button pressed during LED flash! Writing password to card...");
        if (selectCard(false)) {
          if (passwordSet) {
            writeToCard(storedPassword);
            flashBothLEDs(5);  // Flash both LEDs 5 times to indicate successful write
            Serial.println("Password written successfully!");
          } else {
            Serial.println("No password set. Use 'password set X' to set one.");
          }
        } else {
          Serial.println("Error: Card no longer detected. Please scan card again.");
        }
        // Turn off flashing LED and reset all flags
        if (ledFlashPin != -1) {
          digitalWrite(ledFlashPin, LOW);
        }
        digitalWrite(GREEN_LED, LOW);
        digitalWrite(RED_LED, LOW);
        ledFlashing = false;
        ledFlashPin = -1;
        ledState = false;
      }
    }
  } else if (ledFlashing) {
    // LED flash window expired - turn off LED and reset flags
    if (ledFlashPin != -1) {
      digitalWrite(ledFlashPin, LOW);
    }
    digitalWrite(GREEN_LED, LOW);
    digitalWrite(RED_LED, LOW);
    ledFlashing = false;
    ledFlashPin = -1;
    ledState = false;
  } else {
    // Safety check: ensure LEDs are off when not flashing
    // Only after system has been running for 1 second
    if (millis() > 1000) {
      digitalWrite(GREEN_LED, LOW);
      digitalWrite(RED_LED, LOW);
    }
  }
  
  // Debug: Check for button press when LED is not flashing
  if (!ledFlashing) {
    if (digitalRead(BUTTON_PIN) == LOW) {
      delay(5);  // Minimal debounce time
      if (digitalRead(BUTTON_PIN) == LOW) {
        Serial.println("Button pressed but no card detected.");
      }
    }
  }
  
  // ========================================================================
  // RFID CARD DETECTION AND PROCESSING
  // ========================================================================
  // Continuously scan for RFID cards
  if (selectCard(true)) {
    // Reset any previous LED state before processing new card
    if (ledFlashing) {
      digitalWrite(GREEN_LED, LOW);
      digitalWrite(RED_LED, LOW);
      ledFlashing = false;
      ledFlashPin = -1;
      ledState = false;
    }
    
    // Mark that a card was detected and record timestamp
    cardDetected = true;
    cardDetectedTime = millis();
    
    // Display the card's unique identifier (UID)
    Serial.print("Card UID: ");
    dumpHex((char*)serNum, 4);
    Serial.println();
    
    // Read and display all readable memory blocks from the card
    Serial.println("Card Memory:");
    readCardMemory();
    
    // Check if the card contains the stored password
    if (passwordSet) {
      checkCardPassword();  // This will set LED blinking based on result
    } else {
      Serial.println("No password set. Use 'password set X' to set one.");
      Serial.println("Press button within 3 seconds to write password to card.");
    }
    
    // Non-blocking delay that allows LED blinking to continue
    unsigned long delayStart = millis();
    while (millis() - delayStart < 1000) {
      // Allow LED blinking to continue during delay
      if (ledFlashing && (millis() - ledFlashStartTime < AUTHORIZED_WINDOW)) {
        if (millis() - lastLedToggle >= LED_BLINK_INTERVAL) {
          ledState = !ledState;
          digitalWrite(ledFlashPin, ledState ? HIGH : LOW);
          lastLedToggle = millis();
        }
      }
      delay(10); // Small delay to prevent tight loop
    }
  }
  
  // Reset for next loop
  MFRC522_Init();
  
  // Non-blocking delay that allows LED blinking to continue
  unsigned long delayStart2 = millis();
  while (millis() - delayStart2 < 500) {
    // Allow LED blinking to continue during delay
    if (ledFlashing && (millis() - ledFlashStartTime < AUTHORIZED_WINDOW)) {
      if (millis() - lastLedToggle >= LED_BLINK_INTERVAL) {
        ledState = !ledState;
        digitalWrite(ledFlashPin, ledState ? HIGH : LOW);
        lastLedToggle = millis();
      }
    }
    delay(10); // Small delay to prevent tight loop
  }
}

// ============================================================================
// SERIAL COMMAND PROCESSING
// ============================================================================
// Processes commands received via serial monitor
// Commands: "password set X" or "rfid write X"
void checkSerialCommands(String inputCommand) {
  // Debug: Show exactly what was received
  Serial.print("RAW CMD: '");
  Serial.print(inputCommand);
  Serial.print("'  len=");
  Serial.println(inputCommand.length());
  
  // Clean up the command string
  String command = inputCommand;
  command.trim();        // Remove leading/trailing whitespace (\r, spaces, \n)
  command.toLowerCase(); // Make commands case-insensitive

  // Ignore empty commands (e.g., just pressing Enter sends \r\n)
  if (command.length() == 0) {
    Serial.println("(Empty command ignored)");
    return;
  }

  // ========================================================================
  // PASSWORD SET COMMAND
  // ========================================================================
  // Format: "password set X" where X is the password to store
  if (command.startsWith("password set ")) {
    // Extract password from command (remove "password set " prefix)
    String newPassword = command.substring(String("password set ").length());
    newPassword.trim();

    int pwdLen = newPassword.length();
    // Validate password length
    if (pwdLen > 0 && pwdLen <= PASSWORD_MAX_LEN) {
      // Clear the password array
      for (int i = 0; i < PASSWORD_MAX_LEN + 1; i++) {
        storedPassword[i] = '\0';
      }

      // Copy new password to storage array
      newPassword.toCharArray(storedPassword, PASSWORD_MAX_LEN + 1);
      storedPassword[pwdLen] = '\0';  // Ensure null termination
      passwordSet = true;
      
      // Save password to non-volatile FRAM memory
      savePassword(pwdLen);

      // Confirm password was set
      Serial.print("Password set to: ");
      Serial.println(storedPassword);
      Serial.print("Length stored: ");
      Serial.println(pwdLen);
    } else {
      Serial.print("Error: Password must be 1-");
      Serial.print(PASSWORD_MAX_LEN);
      Serial.println(" characters");
    }
  }

  // ========================================================================
  // RFID WRITE COMMAND
  // ========================================================================
  // Format: "rfid write X" where X is the data to write to card
  else if (command.startsWith("rfid write ")) {
    // Extract data from command (remove "rfid write " prefix)
    String dataToWrite = command.substring(String("rfid write ").length());
    dataToWrite.trim();

    if (dataToWrite.length() > 0) {
      Serial.print("Writing to card: ");
      Serial.println(dataToWrite);

      // Check if a card is present, then write data to it
      if (selectCard(false)) {
        writeToCard(dataToWrite.c_str());
      } else {
        Serial.println("Error: No card detected");
      }
    } else {
      Serial.println("Error: No data to write");
    }
  }

  // Unknown command - display error message
  else {
    Serial.print("Unknown command: '");
    Serial.print(command);
    Serial.println("'");
  }
}

/*
  SerialEvent occurs whenever a new data comes in the
  hardware serial RX. This routine is run between each
  time loop() runs, so using delay inside loop can delay
  response. Multiple bytes of data may be available.
  
  This function reads characters until a newline is found,
  handling the case where data arrives in chunks due to
  serial buffer limitations.
*/
void serialEvent() {
  // Keep reading until we find a newline or run out of data
  // This handles cases where data arrives in multiple chunks
  while (Serial.available() && !stringComplete) {
    char inChar = (char)Serial.read();
    inputString += inChar;
    
    // If we receive a newline or carriage return, mark the string as complete
    if (inChar == '\n' || inChar == '\r') {
      stringComplete = true;
      // If we got \r, check if next char is \n and consume it
      if (inChar == '\r' && Serial.available() && Serial.peek() == '\n') {
        Serial.read();      // Consume the \n
        inputString += '\n'; // Add it to the string for consistency
      }
      break;  // Stop reading once we have a complete line
    }
  }
}

// ============================================================================
// CARD PASSWORD CHECKING
// ============================================================================
// Searches the RFID card's memory for the stored password
// Tries multiple authentication keys to access different card types
void checkCardPassword() {
  uchar status;
  uchar buffer[MAX_LEN];
  bool passwordFound = false;
  
  // Search through all data blocks on the card
  // Start from block 4 to avoid sector 0 (manufacturer data)
  for (int block = 4; block < 64; block++) {
    // Skip sector trailer blocks (every 4th block starting from block 3)
    if (block % 4 == 3) continue;
    
    // Try to authenticate with default key first
    status = MFRC522_Auth(PICC_AUTHENT1A, block, defaultKeyA, serNum);
    // If default key fails, try MAD key
    if (status != MI_OK) {
      selectCard(false);
      status = MFRC522_Auth(PICC_AUTHENT1A, block, madKeyA, serNum);
    }
    // If MAD key fails, try NDEF key
    if (status != MI_OK) {
      selectCard(false);
      status = MFRC522_Auth(PICC_AUTHENT1A, block, NDEFKeyA, serNum);
    }
    
    // If authentication succeeded, read and search the block
    if (status == MI_OK) {
      status = MFRC522_Read(block, buffer);
      if (status == MI_OK) {
        // Extract printable ASCII characters from the block
        String blockData = "";
        for (int i = 0; i < MAX_LEN; i++) {
          if (buffer[i] >= 32 && buffer[i] <= 126) {  // Printable ASCII range
            blockData += (char)buffer[i];
          }
        }
        
        // Check if the stored password exists in this block's data
        if (blockData.indexOf(storedPassword) >= 0) {
          passwordFound = true;
          break;  // Stop searching once password is found
        }
      }
    }
  }
  
  // ========================================================================
  // SET LED BLINKING BASED ON AUTHENTICATION RESULT
  // ========================================================================
  if (passwordFound) {
    // Password found - authorized card
    Serial.println("*** AUTHORIZED CARD - Password found! ***");
    authorizedCardDetected = true;
    authorizedTime = millis();
    
    // Configure green LED to blink for 3 seconds
    ledFlashing = true;
    ledFlashStartTime = millis();
    ledFlashPin = GREEN_LED;
    ledState = true;
    lastLedToggle = millis();
    digitalWrite(GREEN_LED, HIGH);
  } else {
    // Password not found - unauthorized card
    Serial.println("*** UNAUTHORIZED CARD - Password not found ***");
    authorizedCardDetected = false;
    
    // Configure red LED to blink for 3 seconds
    ledFlashing = true;
    ledFlashStartTime = millis();
    ledFlashPin = RED_LED;
    ledState = true;
    lastLedToggle = millis();
    digitalWrite(RED_LED, HIGH);
  }
}

// ============================================================================
// CARD MEMORY READING
// ============================================================================
// Reads and displays all readable memory blocks from the RFID card
// Tries multiple authentication keys to access as much data as possible
void readCardMemory() {
  uchar status;
  uchar buffer[MAX_LEN];
  
  // Read all 64 blocks of the card
  for (int block = 0; block < 64; block++) {
    // Try to authenticate with default key first
    status = MFRC522_Auth(PICC_AUTHENT1A, block, defaultKeyA, serNum);
    // If default key fails, try MAD key
    if (status != MI_OK) {
      selectCard(false);
      status = MFRC522_Auth(PICC_AUTHENT1A, block, madKeyA, serNum);
    }
    // If MAD key fails, try NDEF key
    if (status != MI_OK) {
      selectCard(false);
      status = MFRC522_Auth(PICC_AUTHENT1A, block, NDEFKeyA, serNum);
    }
    
    // If authentication succeeded, read and display the block
    if (status == MI_OK) {
      status = MFRC522_Read(block, buffer);
      if (status == MI_OK) {
        // Display sector header when starting a new sector
        if (block % 4 == 0) {
          Serial.print("Sector ");
          Serial.print(block / 4, DEC);
          Serial.println(":");
        }
        // Display block number and hex data
        Serial.print("Block ");
        Serial.print(block, DEC);
        Serial.print(": ");
        dumpHex((char*)buffer, MAX_LEN);
        Serial.println();
      }
    }
  }
}

// ============================================================================
// CARD WRITING
// ============================================================================
// Writes data to the first writable block on the RFID card
// Used for writing passwords or other data to cards
void writeToCard(const char* data) {
  uchar status;
  uchar writeBuffer[16];  // MIFARE blocks are 16 bytes
  int dataLen = strlen(data);
  
  // Start from block 4 to avoid sector 0 (manufacturer data) and sector trailers
  int writeBlock = 4;
  
  // Clear the write buffer (fill with zeros)
  for (int i = 0; i < 16; i++) {
    writeBuffer[i] = 0;
  }
  
  // Copy data to buffer (max 16 bytes per MIFARE block)
  int copyLen = (dataLen < 16) ? dataLen : 16;
  for (int i = 0; i < copyLen; i++) {
    writeBuffer[i] = data[i];
  }
  
  // Try to authenticate with default key first
  status = MFRC522_Auth(PICC_AUTHENT1A, writeBlock, defaultKeyA, serNum);
  // If default key fails, try MAD key
  if (status != MI_OK) {
    selectCard(false);
    status = MFRC522_Auth(PICC_AUTHENT1A, writeBlock, madKeyA, serNum);
  }
  // If MAD key fails, try NDEF key
  if (status != MI_OK) {
    selectCard(false);
    status = MFRC522_Auth(PICC_AUTHENT1A, writeBlock, NDEFKeyA, serNum);
  }
  
  // If authentication succeeded, write the data
  if (status == MI_OK) {
    status = MFRC522_Write(writeBlock, writeBuffer);
    if (status == MI_OK) {
      Serial.print("Successfully wrote to block ");
      Serial.println(writeBlock);
      Serial.print("Data: ");
      // Display the written data
      for (int i = 0; i < copyLen; i++) {
        Serial.print((char)writeBuffer[i]);
      }
      Serial.println();
    } else {
      Serial.println("Write failed!");
    }
  } else {
    Serial.println("Authentication failed for writing!");
  }
}

// ============================================================================
// LED HELPER FUNCTIONS
// ============================================================================

// Blinks a single LED for a specified duration (blocking function)
// Note: Not currently used - non-blocking LED implementation is used instead
void blinkLED(int pin, int duration) {
  int interval = 200;  // Blink interval in milliseconds
  int iterations = duration / (interval * 2);  // Calculate number of on/off cycles
  
  for (int i = 0; i < iterations; i++) {
    digitalWrite(pin, HIGH);
    delay(interval);
    digitalWrite(pin, LOW);
    delay(interval);
  }
}

// Flashes both LEDs simultaneously (used for write confirmation)
// Called after successfully writing password to a card
void flashBothLEDs(int times) {
  // Flash both green and red LEDs together quickly
  for (int i = 0; i < times; i++) {
    digitalWrite(GREEN_LED, HIGH);
    digitalWrite(RED_LED, HIGH);
    delay(100);  // Quick flash on
    digitalWrite(GREEN_LED, LOW);
    digitalWrite(RED_LED, LOW);
    delay(100);  // Quick flash off
  }
}

// ============================================================================
// PASSWORD STORAGE FUNCTIONS (FRAM)
// ============================================================================
// FRAM (Ferroelectric RAM) on MSP430FR6989 can be written like regular memory
// Storage format: [flag byte][length byte][password bytes...]

// Saves the password to non-volatile FRAM memory
void savePassword(int pwdLen) {
  volatile char *fram_ptr = (volatile char *)FRAM_PASSWORD_BASE;
  
  // Write password set flag (1 = password exists, 0 = no password)
  *fram_ptr++ = passwordSet ? 1 : 0;
  
  if (passwordSet) {
    *fram_ptr++ = (char)pwdLen;  // Write password length
    // Write password string bytes
    for (int i = 0; i < pwdLen; i++) {
      *fram_ptr++ = storedPassword[i];
    }
  }
}

// Loads the password from non-volatile FRAM memory
// Called at startup to restore previously saved password
void loadPassword() {
  volatile char *fram_ptr = (volatile char *)FRAM_PASSWORD_BASE;
  
  // Read password set flag
  passwordSet = (*fram_ptr++ == 1);
  
  if (passwordSet) {
    int len = *fram_ptr++;  // Read password length
    // Validate length and read password
    if (len > 0 && len <= PASSWORD_MAX_LEN) {
      // Read password string bytes
      for (int i = 0; i < len; i++) {
        storedPassword[i] = *fram_ptr++;
      }
      storedPassword[len] = '\0';  // Null terminate the string
    } else {
      // Invalid length - reset password flag
      passwordSet = false;
    }
  }
}

// ============================================================================
// LOW-LEVEL RFID FUNCTIONS
// ============================================================================
// These functions provide direct access to the MFRC522 RFID reader
// Based on the MFRC522 library for Energia
// ============================================================================

// Detects and selects an RFID card
// Returns true if a card is detected and selected successfully
// dumpInfo: if true, displays card information (UID, ATQA, SAK) to serial
boolean selectCard(boolean dumpInfo) {
  uchar status;
  uchar buffer[MAX_LEN];
  
  status = MFRC522_Request(PICC_REQIDL, buffer);
  if (status == MI_OK) {
    if (dumpInfo) {
      Serial.print("Card detected. ATQA:");
      dumpHex((char*)buffer, 2);
      Serial.println();
    }
    
    status = MFRC522_Anticoll(buffer);
    if (status == MI_OK) {
      memcpy(serNum, buffer, 5);
      uchar sak = 0;
      status = MFRC522_SelectTag(serNum, &sak);
      
      if (status == MI_OK && ((sak & 0x04) == 0x00)) {
        if (dumpInfo) {
          Serial.print("UID: ");
          dumpHex((char*)serNum, 4);
          Serial.println();
        }
        
        if ((sak & 0x20) == 0x20) {
          uchar ats[MAX_LEN];
          uint unLen = 0;
          status = MFRC522_RATS(ats, &unLen);
          if (status == MI_OK && dumpInfo) {
            Serial.print("ATS: ");
            dumpHex((char*)ats, ats[0]);
            Serial.println();
          }
        }
        
        if (dumpInfo) {
          Serial.print("SAK: ");
          Serial.print(sak, HEX);
          Serial.println();
        }
        return true;
      } else {
        memcpy(serNum7, &serNum[1], 3);
        status = MFRC522_Anticoll2(buffer);
        if (status == MI_OK) {
          memcpy(&serNum7[3], buffer, 4);
          status = MFRC522_SelectTag2(&serNum7[3], &sak);
          if (dumpInfo) {
            Serial.print("UID: ");
            dumpHex((char*)serNum7, 7);
            Serial.println();
            Serial.print("SAK: ");
            Serial.print(sak, HEX);
            Serial.println();
          }
          return true;
        }
      }
    }
  }
  return false;
}

void Write_MFRC522(uchar addr, uchar val) {
  digitalWrite(chipSelectPin, LOW);
  SPI.transfer((addr<<1)&0x7E);
  SPI.transfer(val);
  digitalWrite(chipSelectPin, HIGH);
}

uchar Read_MFRC522(uchar addr) {
  uchar val;
  digitalWrite(chipSelectPin, LOW);
  SPI.transfer(((addr<<1)&0x7E) | 0x80);
  val = SPI.transfer(0x00);
  digitalWrite(chipSelectPin, HIGH);
  return val;
}

void SetBitMask(uchar reg, uchar mask) {
  uchar tmp;
  tmp = Read_MFRC522(reg);
  Write_MFRC522(reg, tmp | mask);
}

void ClearBitMask(uchar reg, uchar mask) {
  uchar tmp;
  tmp = Read_MFRC522(reg);
  Write_MFRC522(reg, tmp & (~mask));
}

void AntennaOn(void) {
  uchar temp;
  temp = Read_MFRC522(TxControlReg);
  if (!(temp & 0x03)) {
    SetBitMask(TxControlReg, 0x03);
  }
}

void AntennaOff(void) {
  ClearBitMask(TxControlReg, 0x03);
}

void MFRC522_Reset(void) {
  Write_MFRC522(CommandReg, PCD_RESETPHASE);
}

void MFRC522_Init(void) {
  digitalWrite(NRSTPD, HIGH);
  MFRC522_Reset();
  
  Write_MFRC522(TModeReg, 0x8D);
  Write_MFRC522(TPrescalerReg, 0x3E);
  Write_MFRC522(TReloadRegL, 30);
  Write_MFRC522(TReloadRegH, 0);
  
  Write_MFRC522(TxAutoReg, 0x40);
  Write_MFRC522(ModeReg, 0x3D);
  AntennaOn();
}

uchar MFRC522_Request(uchar reqMode, uchar *TagType) {
  uchar status;
  uint backBits;
  
  Write_MFRC522(BitFramingReg, 0x07);
  TagType[0] = reqMode;
  status = MFRC522_ToCard(PCD_TRANSCEIVE, TagType, 1, TagType, &backBits);
  
  if ((status != MI_OK) || (backBits != 0x10)) {
    status = MI_ERR;
  }
  return status;
}

uchar MFRC522_ToCard(uchar command, uchar *sendData, uchar sendLen, uchar *backData, uint *backLen) {
  uchar status = MI_ERR;
  uchar irqEn = 0x00;
  uchar waitIRq = 0x00;
  uchar lastBits;
  uchar n;
  uint i;
  
  switch (command) {
    case PCD_AUTHENT:
      irqEn = 0x12;
      waitIRq = 0x10;
      break;
    case PCD_TRANSCEIVE:
      irqEn = 0x77;
      waitIRq = 0x30;
      break;
    default:
      break;
  }
  
  Write_MFRC522(CommIEnReg, irqEn|0x80);
  ClearBitMask(CommIrqReg, 0x80);
  SetBitMask(FIFOLevelReg, 0x80);
  
  Write_MFRC522(CommandReg, PCD_IDLE);
  
  for (i=0; i<sendLen; i++) {
    Write_MFRC522(FIFODataReg, sendData[i]);
  }
  
  Write_MFRC522(CommandReg, command);
  if (command == PCD_TRANSCEIVE) {
    SetBitMask(BitFramingReg, 0x80);
  }
  
  i = 2000;
  do {
    n = Read_MFRC522(CommIrqReg);
    i--;
  } while ((i!=0) && !(n&0x01) && !(n&waitIRq));
  
  ClearBitMask(BitFramingReg, 0x80);
  
  if (i != 0) {
    if(!(Read_MFRC522(ErrorReg) & 0x1B)) {
      status = MI_OK;
      if (n & irqEn & 0x01) {
        status = MI_NOTAGERR;
      }
      if (command == PCD_TRANSCEIVE) {
        n = Read_MFRC522(FIFOLevelReg);
        lastBits = Read_MFRC522(ControlReg) & 0x07;
        if (lastBits) {
          *backLen = (n-1)*8 + lastBits;
        } else {
          *backLen = n*8;
        }
        if (n == 0) {
          n = 1;
        }
        if (n > MAX_LEN) {
          n = MAX_LEN;
        }
        
        for (i=0; i<n; i++) {
          backData[i] = Read_MFRC522(FIFODataReg);
        }
      }
    } else {
      status = MI_ERR;
    }
  }
  return status;
}

uchar MFRC522_Anticoll(uchar *serNum) {
  uchar status;
  uchar i;
  uchar serNumCheck=0;
  uint unLen;
  
  Write_MFRC522(BitFramingReg, 0x00);
  
  serNum[0] = PICC_ANTICOLL;
  serNum[1] = 0x20;
  status = MFRC522_ToCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen);
  
  if (status == MI_OK) {
    for (i=0; i<4; i++) {
      serNumCheck ^= serNum[i];
    }
    if (serNumCheck != serNum[i]) {
      status = MI_ERR;
    }
  }
  return status;
}

uchar MFRC522_Anticoll2(uchar *serNum) {
  uchar status;
  uchar i;
  uchar serNumCheck=0;
  uint unLen;
  
  Write_MFRC522(BitFramingReg, 0x00);
  
  serNum[0] = PICC_ANTICOLL2;
  serNum[1] = 0x20;
  status = MFRC522_ToCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen);
  
  if (status == MI_OK) {
    for (i=0; i<4; i++) {
      serNumCheck ^= serNum[i];
    }
    if (serNumCheck != serNum[i]) {
      status = MI_ERR;
    }
  }
  return status;
}

uchar MFRC522_RATS(uchar *recvData, uint *pLen) {
  uchar status;
  uint unLen = 0;
  recvData[0] = 0xE0;
  recvData[1] = 0x50;
  CalulateCRC(recvData, 2, &recvData[2]);
  status = MFRC522_ToCard(PCD_TRANSCEIVE, recvData, 4, recvData, &unLen);
  return status;
}

void CalulateCRC(uchar *pIndata, uchar len, uchar *pOutData) {
  uchar i, n;
  ClearBitMask(DivIrqReg, 0x04);
  SetBitMask(FIFOLevelReg, 0x80);
  
  for (i=0; i<len; i++) {
    Write_MFRC522(FIFODataReg, *(pIndata+i));
  }
  Write_MFRC522(CommandReg, PCD_CALCCRC);
  
  i = 0xFF;
  do {
    n = Read_MFRC522(DivIrqReg);
    i--;
  } while ((i!=0) && !(n&0x04));
  
  pOutData[0] = Read_MFRC522(CRCResultRegL);
  pOutData[1] = Read_MFRC522(CRCResultRegM);
}

uchar MFRC522_SelectTag(uchar *serNum, uchar *sak) {
  uchar i;
  uchar status;
  uint recvBits;
  uchar buffer[9];
  
  buffer[0] = PICC_SElECTTAG;
  buffer[1] = 0x70;
  for (i=0; i<5; i++) {
    buffer[i+2] = *(serNum+i);
  }
  CalulateCRC(buffer, 7, &buffer[7]);
  status = MFRC522_ToCard(PCD_TRANSCEIVE, buffer, 9, buffer, &recvBits);
  status = MI_OK;
  *sak = buffer[0];
  return status;
}

uchar MFRC522_SelectTag2(uchar *serNum, uchar *sak) {
  uchar i;
  uchar status;
  uint recvBits;
  uchar buffer[9];
  
  buffer[0] = PICC_ANTICOLL2;
  buffer[1] = 0x70;
  for (i=0; i<5; i++) {
    buffer[i+2] = *(serNum+i);
  }
  CalulateCRC(buffer, 7, &buffer[7]);
  status = MFRC522_ToCard(PCD_TRANSCEIVE, buffer, 9, buffer, &recvBits);
  status = MI_OK;
  *sak = buffer[0];
  return status;
}

uchar MFRC522_Auth(uchar authMode, uchar BlockAddr, uchar *Sectorkey, uchar *serNum) {
  uchar status;
  uint recvBits;
  uchar i;
  uchar buff[12];
  
  buff[0] = authMode;
  buff[1] = BlockAddr;
  for (i=0; i<6; i++) {
    buff[i+2] = *(Sectorkey+i);
  }
  for (i=0; i<4; i++) {
    buff[i+8] = *(serNum+i);
  }
  status = MFRC522_ToCard(PCD_AUTHENT, buff, 12, buff, &recvBits);
  
  if ((status != MI_OK) || (!(Read_MFRC522(Status2Reg) & 0x08))) {
    status = MI_ERR;
  }
  return status;
}

uchar MFRC522_Read(uchar blockAddr, uchar *recvData) {
  uchar status;
  uint unLen;
  recvData[0] = PICC_READ;
  recvData[1] = blockAddr;
  CalulateCRC(recvData, 2, &recvData[2]);
  status = MFRC522_ToCard(PCD_TRANSCEIVE, recvData, 4, recvData, &unLen);
  if ((status != MI_OK) || (unLen != 0x90)) {
    status = MI_ERR;
  }
  return status;
}

uchar MFRC522_Write(uchar blockAddr, uchar *writeData) {
  uchar status;
  uint recvBits;
  uchar i;
  uchar buff[18];
  
  buff[0] = PICC_WRITE;
  buff[1] = blockAddr;
  CalulateCRC(buff, 2, &buff[2]);
  status = MFRC522_ToCard(PCD_TRANSCEIVE, buff, 4, buff, &recvBits);
  
  if ((status != MI_OK) || (recvBits != 4) || ((buff[0] & 0x0F) != 0x0A)) {
    status = MI_ERR;
  }
  
  if (status == MI_OK) {
    for (i=0; i<16; i++) {
      buff[i] = *(writeData+i);
    }
    CalulateCRC(buff, 16, &buff[16]);
    status = MFRC522_ToCard(PCD_TRANSCEIVE, buff, 18, buff, &recvBits);
    
    if ((status != MI_OK) || (recvBits != 4) || ((buff[0] & 0x0F) != 0x0A)) {
      status = MI_ERR;
    }
  }
  return status;
}

void MFRC522_Halt(void) {
  uchar status;
  uint unLen;
  uchar buff[4];
  
  buff[0] = PICC_HALT;
  buff[1] = 0;
  CalulateCRC(buff, 2, &buff[2]);
  status = MFRC522_ToCard(PCD_TRANSCEIVE, buff, 4, buff, &unLen);
}

void dumpHex(char* buffer, int len) {
  for(byte i=0; i < len; i++) {
    char text[4];
    if (i % 16 == 0) {
      Serial.print(" ");
    }
    sprintf(text, "%02X ", (byte)(*(buffer + i)));
    Serial.print(text);
    
    if (i % 16 == 15) {
      Serial.println();
    }
  }
}
